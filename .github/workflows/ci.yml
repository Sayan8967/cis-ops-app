name: CI/CD Pipeline

on:
  push:
    branches: [ release ]
  pull_request:
    branches: [ release ]

env:
  DOCKER_REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
  BACKEND_IMAGE: cis-ops-backend
  FRONTEND_IMAGE: cis-ops-frontend

jobs:
  # Backend Build Job
  build-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json
          
      - name: Install backend dependencies
        run: |
          cd backend
          npm ci
          
      - name: Build backend
        run: |
          cd backend
          npm run build --if-present

  # Frontend Build Job
  build-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
          
      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci
          
      - name: Build frontend
        run: |
          cd frontend
          npm run build
        env:
          REACT_APP_HF_API_KEY: ${{ secrets.REACT_APP_HF_API_KEY }}
          REACT_APP_GOOGLE_CLIENT_ID: ${{ secrets.REACT_APP_GOOGLE_CLIENT_ID }}

  # Docker Build Jobs
  docker-backend:
    needs: build-backend
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Login to Docker Registry
        run: |
          docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_REGISTRY_KEY }}

      - name: Build and Push Backend Docker image
        run: |
          cd backend
          docker build -t ${{ env.DOCKER_REGISTRY }}/${{ env.BACKEND_IMAGE }}:${{ github.sha }} .
          docker push ${{ env.DOCKER_REGISTRY }}/${{ env.BACKEND_IMAGE }}:${{ github.sha }}

  docker-frontend:
    needs: build-frontend
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Login to Docker Registry
        run: |
          docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_REGISTRY_KEY }}

      - name: Build and Push Frontend Docker image
        run: |
          cd frontend
          docker build --build-arg REACT_APP_HF_API_KEY=${{ secrets.REACT_APP_HF_API_KEY }} \
                       --build-arg REACT_APP_GOOGLE_CLIENT_ID=${{ secrets.REACT_APP_GOOGLE_CLIENT_ID }} \
                       -t ${{ env.DOCKER_REGISTRY }}/${{ env.FRONTEND_IMAGE }}:${{ github.sha }} .
          docker push ${{ env.DOCKER_REGISTRY }}/${{ env.FRONTEND_IMAGE }}:${{ github.sha }}

  # Security Scanning
  trivy-scan-backend:
    needs: docker-backend
    runs-on: ubuntu-latest
    steps:
      - uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.DOCKER_REGISTRY }}/${{ env.BACKEND_IMAGE }}:${{ github.sha }}

  trivy-scan-frontend:
    needs: docker-frontend
    runs-on: ubuntu-latest
    steps:
      - uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.DOCKER_REGISTRY }}/${{ env.FRONTEND_IMAGE }}:${{ github.sha }}

  # Generate Kubernetes Manifests
  k8s-manifest:
    needs: [trivy-scan-backend, trivy-scan-frontend]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure Git
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

      - name: Generate Kubernetes manifests
        run: |
          mkdir -p deployment
          
          # Create Namespace
          cat <<EOF > deployment/namespace.yml
          apiVersion: v1
          kind: Namespace
          metadata:
            name: cis-ops
          EOF
          
          # Create Backend Deployment and Service
          cat <<EOF > deployment/backend.yml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: cis-ops-backend
            namespace: cis-ops
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: cis-ops-backend
            template:
              metadata:
                labels:
                  app: cis-ops-backend
              spec:
                containers:
                - name: backend
                  image: ${{ env.DOCKER_REGISTRY }}/${{ env.BACKEND_IMAGE }}:${{ github.sha }}
                  ports:
                  - containerPort: 4000
                  env:
                  - name: NODE_ENV
                    value: "production"
                  - name: PORT
                    value: "4000"
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: cis-ops-backend-service
            namespace: cis-ops
          spec:
            selector:
              app: cis-ops-backend
            ports:
            - port: 4000
              targetPort: 4000
            type: ClusterIP
          EOF
          
          # Create Frontend Deployment and Service
          cat <<EOF > deployment/frontend.yml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: cis-ops-frontend
            namespace: cis-ops
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: cis-ops-frontend
            template:
              metadata:
                labels:
                  app: cis-ops-frontend
              spec:
                containers:
                - name: frontend
                  image: ${{ env.DOCKER_REGISTRY }}/${{ env.FRONTEND_IMAGE }}:${{ github.sha }}
                  ports:
                  - containerPort: 80
                  resources:
                    requests:
                      memory: "128Mi"
                      cpu: "100m"
                    limits:
                      memory: "256Mi"
                      cpu: "200m"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: cis-ops-frontend-service
            namespace: cis-ops
          spec:
            selector:
              app: cis-ops-frontend
            ports:
            - port: 80
              targetPort: 80
            type: ClusterIP
          EOF
          
          # Create Ingress
          cat <<EOF > deployment/ingress.yml
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: cis-ops-ingress
            namespace: cis-ops
            annotations:
              nginx.ingress.kubernetes.io/rewrite-target: /\$2
              nginx.ingress.kubernetes.io/use-regex: "true"
              nginx.ingress.kubernetes.io/ssl-redirect: "false"
              nginx.ingress.kubernetes.io/enable-cors: "true"
              nginx.ingress.kubernetes.io/cors-allow-methods: "GET, PUT, POST, DELETE, PATCH, OPTIONS"
              nginx.ingress.kubernetes.io/cors-allow-origin: "*"
              nginx.ingress.kubernetes.io/cors-allow-credentials: "true"
              nginx.ingress.kubernetes.io/cors-allow-headers: "*"
          spec:
            ingressClassName: nginx
            rules:
            - http:
                paths:
                - path: /api(/|$)(.*)
                  pathType: ImplementationSpecific
                  backend:
                    service:
                      name: cis-ops-backend-service
                      port:
                        number: 4000
                - path: /socket.io(/|$)(.*)
                  pathType: ImplementationSpecific
                  backend:
                    service:
                      name: cis-ops-backend-service
                      port:
                        number: 4000
                - path: /()(.*)
                  pathType: ImplementationSpecific
                  backend:
                    service:
                      name: cis-ops-frontend-service
                      port:
                        number: 80
          EOF
          
          # Create deployment script
          cat <<EOF > deployment/deploy.sh
          #!/bin/bash
          set -e
          
          echo "ðŸš€ Deploying CIS Operations Dashboard..."
          
          # Detect cluster type and install appropriate NGINX Ingress Controller
          if kubectl get nodes -o jsonpath='{.items[0].metadata.name}' | grep -q "kind"; then
            echo "ðŸ“¦ Detected Kind cluster - Installing NGINX Ingress Controller for Kind..."
            if ! kubectl get namespace ingress-nginx >/dev/null 2>&1; then
              kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/kind/deploy.yaml
              echo "â³ Waiting for NGINX Ingress Controller to be ready..."
              kubectl wait --namespace ingress-nginx --for=condition=ready pod --selector=app.kubernetes.io/component=controller --timeout=300s
            fi
          else
            echo "ðŸ“¦ Installing NGINX Ingress Controller for cloud..."
            if ! kubectl get namespace ingress-nginx >/dev/null 2>&1; then
              kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml
              echo "â³ Waiting for NGINX Ingress Controller to be ready..."
              kubectl wait --namespace ingress-nginx --for=condition=ready pod --selector=app.kubernetes.io/component=controller --timeout=300s
            fi
          fi
          
          # Apply manifests
          echo "ðŸ“‹ Applying Kubernetes manifests..."
          kubectl apply -f namespace.yml
          kubectl apply -f backend.yml
          kubectl apply -f frontend.yml
          kubectl apply -f ingress.yml
          
          # Wait for deployments
          echo "â³ Waiting for deployments to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/cis-ops-backend -n cis-ops
          kubectl wait --for=condition=available --timeout=300s deployment/cis-ops-frontend -n cis-ops
          
          echo "âœ… Deployment completed successfully!"
          echo "ðŸŒ Check ingress status: kubectl get ingress -n cis-ops"
          EOF
          
          chmod +x deployment/deploy.sh

      - name: Commit and push manifests
        run: |
          git pull origin release || echo "No changes to pull"
          git add deployment/
          git commit -m "Update k8s manifests for ${{ github.sha }}" || echo "No changes to commit"
          git push origin HEAD:${{ github.ref_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Image**: \`${{ env.DOCKER_REGISTRY }}/${{ env.BACKEND_IMAGE }}:${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Image**: \`${{ env.DOCKER_REGISTRY }}/${{ env.FRONTEND_IMAGE }}:${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: \`cis-ops\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Run: \`bash deployment/deploy.sh\`" >> $GITHUB_STEP_SUMMARY
          echo "2. Check status: \`kubectl get pods -n cis-ops\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Get ingress IP: \`kubectl get ingress -n cis-ops\`" >> $GITHUB_STEP_SUMMARY